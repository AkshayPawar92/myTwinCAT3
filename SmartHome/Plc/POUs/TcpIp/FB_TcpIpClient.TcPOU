<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_TcpIpClient" Id="{113ef9ab-a832-4d5b-912f-d3ca6aba59e1}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_TcpIpClient
VAR_INPUT
	connect: BOOL;
	srvIpAddr: STRING;	//Server's IP Address
	port: UDINT;
	sData: STRING(255);
	send: BOOL;
	reset: BOOL;
	close: BOOL;
	closeAll: BOOL;
END_VAR
VAR_OUTPUT
	busy: BOOL;
	connected: BOOL;
	bSendSuccess: BOOL;
	sReceivedData: STRING(255);
	nRecBytes: UDINT;
	bRecSuccess: BOOL;
	errId: UDINT;
END_VAR
VAR
	fbConnect: FB_SocketConnect;
	fbClose: FB_SocketClose;
	fbCloseAll: FB_SocketCloseAll;
	fbSend: FB_SocketSend;
	fbReceive: FB_SocketReceive;
	step: (eIdle, eInit, eError, ePreConnect, eConnect, ePreClose, eClose, ePreCloseAll, eCloseAll, ePreSend, eSend);
	step_rec: (eIdle_rec, ePreReceive_rec, eReceive_rec, eWait_rec, eError_rec);
	rtConnect: R_TRIG;
	rtClose: R_TRIG;
	rtCloseAll: R_TRIG;
	rtReset: R_TRIG;
	rtSend: R_TRIG;
	tonWait: TON;
	sReceivedData_loc: STRING(255);	
	M_ErrGeneratedAtRec: BOOL;
END_VAR

VAR CONSTANT
	NullChar: BYTE := 0;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[	rtConnect	(CLK:= connect, Q=> );
	rtClose		(CLK:= close, Q=> );
	rtCloseAll	(CLK:= closeAll, Q=> );	
	rtReset		(CLK:= reset, Q=> );	
	rtSend		(CLK:= send, Q=> );	

	IF bSendSuccess AND (NOT send) THEN
		bSendSuccess			:=	FALSE;
	END_IF
	
	CASE step OF
	eIdle:			
		IF rtConnect.Q THEN
			errId				:=	0;
			busy				:=	TRUE;
			connected			:=	FALSE;
			step				:=	eInit;
		END_IF
		IF rtClose.Q THEN
			fbClose(bExecute	:= FALSE);
			errId				:=	0;
			busy				:=	TRUE;
			step				:=	ePreClose;			
		END_IF
		IF rtCloseAll.Q THEN
			fbCloseAll(	bExecute:= FALSE);
			errId				:=	0; 
			busy				:=	TRUE;
			step				:=	ePreCloseAll;
		END_IF
		IF rtSend.Q THEN
			fbSend(bExecute		:=	FALSE);
			busy				:=	TRUE;
			errId				:=	0;
			step				:=	ePreSend;
		END_IF

	eInit:
	
		fbConnect(
			sSrvNetId		:= '', 
			sRemoteHost		:= srvIpAddr, 
			nRemotePort		:= port, 
			bExecute		:= FALSE, 
			tTimeout		:= DEFAULT_ADS_TIMEOUT, 
			bBusy			=> , 
			bError			=> , 
			nErrId			=> , 
			hSocket			=> );

		fbClose(
			sSrvNetId		:= '', 
			hSocket			:= fbConnect.hSocket, 
			bExecute		:= FALSE, 
			tTimeout		:= DEFAULT_ADS_TIMEOUT, 
			bBusy			=> , 
			bError			=> , 
			nErrId			=> );
			
		fbCloseAll(
			sSrvNetId		:= '', 
			bExecute		:= FALSE, 
			tTimeout		:= DEFAULT_ADS_TIMEOUT, 
			bBusy			=> , 
			bError			=> , 
			nErrId			=> );
			
		fbSend(
			sSrvNetId		:= '', 
			hSocket			:= , 
			cbLen			:= , 
			pSrc			:= , 
			bExecute		:= FALSE, 
			tTimeout		:= DEFAULT_ADS_TIMEOUT, 
			bBusy			=> , 
			bError			=> , 
			nErrId			=> );
			
		step				:=	ePreConnect;
		
	ePreConnect:
		fbConnect(
			bExecute		:= TRUE, 
			tTimeout		:= DEFAULT_ADS_TIMEOUT,  
			hSocket			=> );	
			
		IF fbConnect.bBusy THEN
			step			:=	eConnect;
		ELSIF fbConnect.bError THEN
			errID			:=	fbConnect.nErrId;
			step			:=	eError;	
		END_IF
	
	eConnect:	
		fbConnect(
			bExecute		:= FALSE, 
			tTimeout		:= DEFAULT_ADS_TIMEOUT,  
			hSocket			=> );	
			
		IF (NOT fbConnect.bBusy) AND (NOT fbConnect.bError) AND (fbConnect.hSocket.handle <> 0) THEN
			connected		:=	TRUE;
			busy			:=	FALSE;
			step			:=	eIdle;
		ELSIF fbConnect.bError THEN
			errID			:=	fbConnect.nErrId;
			step			:=	eError;	
		END_IF
		
	ePreClose:
		fbClose(
			hSocket			:= fbConnect.hSocket, 
			bExecute		:= TRUE);
			
		IF fbClose.bBusy THEN
			step			:=	eClose;
		ELSIF fbCLose.bError THEN
			errID			:=	fbClose.nErrId;
			step			:=	eError;
		END_IF
	
	eClose:
		fbClose(
			hSocket			:= fbConnect.hSocket, 
			bExecute		:= FALSE);
			
		IF (NOT fbClose.bBusy) AND (NOT fbClose.bError) THEN
			step			:=	eIdle;
			connected		:=	FALSE;
			busy			:=	FALSE;
		ELSIF fbCLose.bError THEN
			errID			:=	fbClose.nErrId;
			step			:=	eError;
		END_IF
		
	ePreCloseAll:
		fbCloseAll(bExecute		:= TRUE);
			
		IF fbCloseAll.bBusy THEN
			step			:=	eCloseAll;
		ELSIF fbCloseAll.bError THEN
			errID			:=	fbCloseAll.nErrId;
			step			:=	eError;
		END_IF
	
	eCloseAll:
		fbCloseAll(bExecute		:= FALSE);
			
		IF (NOT fbCloseAll.bBusy) AND (NOT fbCloseAll.bError) THEN
			step			:=	eIdle;
			connected		:=	FALSE;
			busy			:=	FALSE;
		ELSIF fbCloseAll.bError THEN
			errID			:=	fbCloseAll.nErrId;
			step			:=	eError;
		END_IF
	
	ePreSend:
		fbSend( 
			hSocket			:= fbConnect.hSocket, 
			cbLen			:= LEN(sData), 
			pSrc			:= ADR(sData), 
			bExecute		:= TRUE);

		IF (fbSend.bBusy) THEN
			step			:=	eSend;
		ELSIF fbSend.bError THEN
			errID			:=	fbSend.nErrId;
			step			:=	eError;
		END_IF
	
	eSend:
		fbSend( 
			hSocket			:= fbConnect.hSocket, 
			cbLen			:= LEN(sData), 
			pSrc			:= ADR(sData), 
			bExecute		:= FALSE);

		IF (NOT fbSend.bBusy) AND (NOT fbSend.bError) THEN
			bSendSuccess	:=	TRUE;
			busy			:=	FALSE;
			step			:=	eIdle;
		ELSIF fbSend.bError THEN
			errID			:=	fbSend.nErrId;
			step			:=	eError;
		END_IF
		
	eError:
		busy				:=	FALSE;
		
		step				:=	eIdle;
//		IF rtReset.Q THEN
//			step			:=	eIdle;
//			errID			:=	0;
//		END_IF
		
	END_CASE
	
//	################################
	CASE step_rec OF
	eIdle_rec:
		IF connected THEN
			fbReceive(
				sSrvNetId		:= '', 
				hSocket			:= fbConnect.hSocket, 
				bExecute		:= FALSE, 
				tTimeout		:= DEFAULT_ADS_TIMEOUT, 
				bBusy			=> , 
				bError			=> , 
				nErrId			=> , 
				nRecBytes		=> nRecBytes);
			
			//MEMCPY(destAddr:= ADR(sReceivedData_loc), srcAddr:= ADR(NullChar), n:= SIZEOF(sReceivedData_loc));	
			tonWait(IN:= FALSE);
			step_rec			:=	ePreReceive_rec;	
		END_IF
		bRecSuccess				:=	FALSE;
		
	ePreReceive_rec:
		fbReceive( 
			cbLen			:= SIZEOF(sReceivedData_loc), 
			pDest			:= ADR(sReceivedData_loc), 
			bExecute		:= TRUE, 
			nRecBytes		=> nRecBytes);	
		
		IF fbReceive.bBusy THEN
			step_rec		:=	eReceive_rec;
		ELSIF fbReceive.bError THEN
			errId			:=	fbReceive.nErrId;
			M_ErrGeneratedAtRec	:=	TRUE;
			step_rec		:=	eError_rec;			
		END_IF
	
	eReceive_rec:
		fbReceive( 
			cbLen			:= SIZEOF(sReceivedData_loc), 
			pDest			:= ADR(sReceivedData_loc), 
			bExecute		:= FALSE, 
			nRecBytes		=> nRecBytes);	
		
		IF (NOT fbReceive.bBusy) AND (NOT fbReceive.bError) THEN			
			IF nRecBytes > 0 THEN				
				sReceivedData		:=	LEFT(sReceivedData_loc, UDINT_TO_INT(nRecBytes));
				bRecSuccess			:=	TRUE;
			END_IF
			step_rec		:=	eWait_rec;			
		ELSIF fbReceive.bError THEN
			errId			:=	fbReceive.nErrId;
			M_ErrGeneratedAtRec	:=	TRUE;
			step_rec		:=	eError_rec;
		END_IF	
			
	eWait_rec:
		tonWait(IN:= TRUE, PT:= T#2S, Q=> , ET=> );
		IF tonWait.Q THEN
			step_rec			:=	eIdle_rec;
			tonWait(IN:= FALSE);
		END_IF
		
	eError_rec:
		tonWait(IN:= TRUE, PT:= T#2S, Q=> , ET=> );
		
		fbReceive(
			bExecute		:= FALSE);
			
		IF tonWait.Q THEN
			IF M_ErrGeneratedAtRec THEN
				errId					:=	0;
				M_ErrGeneratedAtRec		:=	FALSE;
			END_IF			
			tonWait(IN:= FALSE);
			step_rec			:=	eIdle_rec;			
		END_IF
		
	END_CASE
	
//	Calling	############################
	fbConnect(
		sSrvNetId		:= , 
		sRemoteHost		:= , 
		nRemotePort		:= , 
		bExecute		:= , 
		tTimeout		:= , 
		bBusy			=> , 
		bError			=> , 
		nErrId			=> , 
		hSocket			=> );
		
	fbClose(
		sSrvNetId		:= , 
		hSocket			:= , 
		bExecute		:= , 
		tTimeout		:= , 
		bBusy			=> , 
		bError			=> , 
		nErrId			=> );
		
	fbCloseAll(
		sSrvNetId		:= , 
		bExecute		:= , 
		tTimeout		:= , 
		bBusy			=> , 
		bError			=> , 
		nErrId			=> );
		
	fbSend(
		sSrvNetId		:= , 
		hSocket			:= , 
		cbLen			:= , 
		pSrc			:= , 
		bExecute		:= , 
		tTimeout		:= , 
		bBusy			=> , 
		bError			=> , 
		nErrId			=> );

	fbReceive(
		sSrvNetId		:= , 
		hSocket			:= , 
		cbLen			:= , 
		pDest			:= , 
		bExecute		:= , 
		tTimeout		:= , 
		bBusy			=> , 
		bError			=> , 
		nErrId			=> , 
		nRecBytes		=> );


]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>